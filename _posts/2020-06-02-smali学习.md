---
title: smali学习
description: 准备尝试安卓逆向，先学习下smali
categories:
 - 安卓
tags:
 - 安卓
 - 逆向
 - 转载
---

# Smali系列学习之smali函数调用语句分析

一.函数调用
smali中的函数和成员变量也分为两种，分别为 direct 和 virtual。两者的区别如下：

1.direct method 是指调用private方法。
2.virtual method 是指调用protected和public方法。
3.static method 是指调用static方法。
4.super method是指调用父类方法。
5.当然其实还有invoke-XXX/range指令的，这是参数多于4个的时候调用的指令，比较少见。

所以在调用函数时，有invoke-direct，invoke-virtual，另外还有invoke-static、invoke-super以及invoke-interface等几种不同的指令。

下面针对这几种函数调用的smali方法进行讲解。

1.invoke-static
用于调用static函数，例如：

``` smali
        invoke-static {}, Lcom/aaa;->CheckSignature()Z
```

注意：invoke-static后面有一对大括号“{}”，其实是调用该方法的实例+参数列表，由于这个方法既不需参数也是static的，所以{}内为空。

例如：

```
　　const-string v0, "NDKLIB"

　　invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```

　　这个是调用static void System.loadLibrary(String)来加载NDK编译的so库用的方法

2.invoke-super

调用父类方法用的指令，一般用于调用onCreate、onDestroy等方法。

3.invoke-direct

调用private函数：

例如：

```
　　invoke-direct {p0}, Landroid/app/TabActivity;-><init>()V
```

　　这里init()就是定义在TabActivity中的一个private函数。

4.invoke-virtual

用于调用protected或public函数，同样注意修改smali时不要错用invoke-direct或invoke-static。

5.invoke-xxxxx/range

当方法的参数多于5个时（含5个），不能直接使用以上的指令，而是在后面加上“/range”，range表示范围，使用方法也有所不同。


二.函数的返回结果

在Java代码中调用函数和返回函数结果可以用一条语句完成，而在Smali里则需要分开来完成，在使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令：
```
　　const-string v0, "Eric"

　　invoke-static {v0}, Lcmb/pbi;->t(Ljava/lang/String;)Ljava/lang/String;

　　move-result-object  v2
```
上述中的v2寄存器保存的就是调用t方法返回的String字符串。

```
Toast.makeText(this, "Hello, Smali", Toast.LENGTH_LONG).show();

.line xx
const-string v0, "Hello, Smali"
const/4  v1, 0x1
invoke-static {p0, v0, v1}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;
move-result-object  v0
invoke-virtual {v0}, Landroid/widget/Toast;->show()V
```
>>> 转载于：https://www.cnblogs.com/eustoma/p/8989136.html

# Smali系列学习之Smali语法

一.smali的包中信息
```
.class  public Lcom/aaaaa;
.super  Lcom/bbbbb;
.source "ccccc.java"
```
1.它是com.aaaaa这个package下的类
2.继承自com.bbbbb
3.由ccccc.java编译得到的smali文件

二.smali中的声明

## annotations

```smali
.annotation system Ldalvik/annotation/MemberClasses;
　　value = {Lcom/aaa$qqq;,
　　　　　   Lcom/aaa$www;
　　　　　 }
.end annotation
```
这个声明是内部类的声明：aaa这个类它有两个成员内部类——qqq和www。

三.寄存器

本地寄存器用v开头数字结尾的符号来表示，如v0、v1、v2、...
参数寄存器则使用p开头数字结尾的符号来表示，如p0、p1、p2、...

注意：p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2代表函数中的第二个参数…而在static函数中p0才对应第一个参数（因为Java的static方法中没有this方法。

简单分析：
```smali
const/4  v0, 0x1
iput-boolean  v0, p0, Lcom/aaa;->IsRegistered:Z
```
上面两句smali代码，首先使用本地v0寄存器，并将0x1存到v0中，然后第二句用iput-boolean这个指令把v0中的值存放到com.aaa.IsRegistered这个成员变量中。

相当于：this.IsRegistered=v0;

四.smali中的成员变量

成员变量格式是：
```smali
.field public/private [static] [final] varName:<类型>。
```
对于不同的成员变量也有不同的指令。

一般来说，
获取的指令有：iget、sget、iget-boolean、sget-boolean、iget-object、sget-object等。
操作的指令有：iput、sput、iput-boolean、sput-boolean、iput-object、sput-object等。

没有“-object”后缀的表示操作的成员变量对象是基本数据类型，带“-object”表示操作的成员变量是对象类型，特别地，boolean类型则使用带“-boolean”的指令操作。

五.Smali成员变量指令简析

1.sget-object v0, Lcom/aaa;->ID:Ljava/lang/String;
sget-object就是用来获取变量值并保存到紧接着的参数的寄存器中
本例中，它获取ID这个String类型的成员变量并放到v0这个寄存器中。
注意：前面需要该变量所属的类的类型，后面需要加一个冒号和该成员变量的类型，中间是“->”表示所属关系。

2.iget-object v0, p0, Lcom/aaa;->view:Lcom/aaa/view;
可以看到iget-object指令比sget-object多了一个参数，就是该变量所在类的实例，在这里就是p0即“this”。

3.sput指令的使用
```
const/4 v3, 0x0
sput-object v3, Lcom/aaa;->timer:Lcom/aaa/timer;
```
相当于：this.timer=null

4.iput指令的使用
```smali
.local v0, args:Landroid/os/Message;
const/4 v1, 0x12
iput v1, v0, Landroid/os/Message;->what:I
```
相当于：args.what = 18;

>>> 转载于：https://www.cnblogs.com/eustoma/p/8990449.html

# Smali系列学习之基础语法
一.什么是Smali？
Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种dex格式文件的汇编器，反汇编器。其语法是一种宽松式的Jasmin/dedexer语法，而且它实现了.dex格式所有功能（注解，调试信息，线路信息等）

二.smali的语法
1.原始类型
B---byte
C---char
D---double
F---float
I---int
J---long
S---short
V---void
Z---boolean
[XXX---array
Lxxx/yyy---object

解析下最后两项，数组的表示方式是：

在基本类型前加上前中括号“[”，例如int数组和float数组分别表示为：[I、[F；
对象的表示则以L作为开头，格式LpackageName/objectName;（注意必须有个分号跟在最后），例如String对象在smali中为：Ljava/lang/String;，其中java/lang对应java.lang包，String就是定义在该包中的一个对象。

2.方法的定义
格式：Func-Name (Para-Type1Para-Type2Para-Type3...)Return-Type

注意：参数和参数间没有任何分隔符，

1.hello()v
　就是void hello()

2.hello(lll)Z
　就是boolean hello(int,int,int)

3.hello(Z[l[lLjava/lang/String;J)Ljava/lang/String
　就是String hello(boolean,int[],int[],String,long)

3.基本语法
.field private isFlag:z　定义变量
.method　　方法
.parameter　　方法参数
.prologue　　方法开始
.line 123　　此方法位于第123行
invoke-super　　调用父函数
const/high16 v0, 0x7fo3　　把0x7fo3赋值给v0
invoke-direct　　调用函数
return-void　　函数返回void
.end method　　函数结束
new-instance　　创建实例
iput-object　　对象赋值
iget-object　　调用对象
invoke-static　　调用静态函数

4.条件跳转分支：
"if-eq vA, vB, :cond_**" 如果vA等于vB则跳转到:cond_**
"if-ne vA, vB, :cond_**" 如果vA不等于vB则跳转到:cond_**
"if-lt vA, vB, :cond_**" 如果vA小于vB则跳转到:cond_**
"if-ge vA, vB, :cond_**" 如果vA大于等于vB则跳转到:cond_**
"if-gt vA, vB, :cond_**" 如果vA大于vB则跳转到:cond_**
"if-le vA, vB, :cond_**" 如果vA小于等于vB则跳转到:cond_**
"if-eqz vA, :cond_**" 如果vA等于0则跳转到:cond_**
"if-nez vA, :cond_**" 如果vA不等于0则跳转到:cond_**
"if-ltz vA, :cond_**" 如果vA小于0则跳转到:cond_**
"if-gez vA, :cond_**" 如果vA大于等于0则跳转到:cond_**
"if-gtz vA, :cond_**" 如果vA大于0则跳转到:cond_**
"if-lez vA, :cond_**" 如果vA小于等于0则跳转到:cond_**

# Smali系列学习之Smali语法详解

数据类型
Dalvik字节码只有两种格式：基本类型和引用类型。对象和数组属于引用类型

语法	含义
V	void，只用于返回值类型
Z	boolean
B	byte
S	short
C	char
I	int
J	long
F	flot
D	double
L	Java类 类型
[	数组类型
Ljava/lang/String; 相当于java.lang.String 
[I 相当于一维int数组，int[] 
[[I 相当于int[][]

方法
它使用方法名，参数类型和返回值来描述一个方法 
package/name/ObjectName;->methodName(III)Z

package/name/ObjectName:一个类 
methodName：方法名 
III：参数类型 
Z：返回值

(III)Z：方法签名

BakSmali生成的方法代码以.method指令开始，以.end method指令结束，根据方法的类型不同，可以会在方法前加#表示方法类型

## vitual methods:虚方法，如：
```
# virtual methods
.method public get(Ljava/lang/String;)Lcn/woblog/markdowndiary/domain/Note;
    .locals 2
    .param p1, "noteId"    # Ljava/lang/String;

    .prologue
    .line 50
    iget-object v0, p0, Lcn/woblog/markdowndiary/repository/LocalNoteRepository;->orm:Lcom/litesuits/orm/LiteOrm;

    const-class v1, Lcn/woblog/markdowndiary/domain/Note;

    invoke-virtual {v0, p1, v1}, Lcom/litesuits/orm/LiteOrm;->queryById(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;

    move-result-object v0

    check-cast v0, Lcn/woblog/markdowndiary/domain/Note;

    return-object v0
.end method
```
## direct methods:直接方法，如：
```
# direct methods
.method public constructor <init>(Landroid/content/Context;)V
    .locals 2
    .param p1, "context"    # Landroid/content/Context;

    .prologue
    .line 22
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    .line 23
    iput-object p1, p0, Lcn/woblog/markdowndiary/repository/LocalNoteRepository;->context:Landroid/content/Context;

    .line 24
    const-string v0, "note.db"

    invoke-static {p1, v0}, Lcom/litesuits/orm/LiteOrm;->newSingleInstance(Landroid/content/Context;Ljava/lang/String;)Lcom/litesuits/orm/LiteOrm;

    move-result-object v0

    iput-object v0, p0, Lcn/woblog/markdowndiary/repository/LocalNoteRepository;->orm:Lcom/litesuits/orm/LiteOrm;

    .line 25
    iget-object v0, p0, Lcn/woblog/markdowndiary/repository/LocalNoteRepository;->orm:Lcom/litesuits/orm/LiteOrm;

    const/4 v1, 0x1

    invoke-virtual {v0, v1}, Lcom/litesuits/orm/LiteOrm;->setDebugged(Z)V

    .line 26
    return-void
.end method
```
有些方法没有这样的注释
```
.method public save(Lcn/woblog/markdowndiary/domain/Note;)V
    .locals 1
    .param p1, "note"    # Lcn/woblog/markdowndiary/domain/Note;

    .prologue
    .line 37
    iget-object v0, p0, Lcn/woblog/markdowndiary/repository/LocalNoteRepository;->orm:Lcom/litesuits/orm/LiteOrm;

    invoke-virtual {v0, p1}, Lcom/litesuits/orm/LiteOrm;->save(Ljava/lang/Object;)J

    .line 38
    return-void
.end method
```
静态方法：
```
.method public static formatTime(J)Ljava/lang/String;
    .locals 4
    .param p0, "date"    # J

    .prologue
    .line 11
    new-instance v0, Ljava/text/SimpleDateFormat;

    const-string v1, "yyyy\u5e74MM\u6708dd\u65e5 EEEE"

    sget-object v2, Ljava/util/Locale;->CHINESE:Ljava/util/Locale;

    invoke-direct {v0, v1, v2}, Ljava/text/SimpleDateFormat;-><init>(Ljava/lang/String;Ljava/util/Locale;)V

    .line 13
    .local v0, "simpleDateFormat":Ljava/text/SimpleDateFormat;
    invoke-static {p0, p1}, Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;

    move-result-object v1

    invoke-virtual {v0, v1}, Ljava/text/SimpleDateFormat;->format(Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v1

    return-object v1
.end method
```
字段
与方法表示很相似，只是字段没有方法签名和返回值，取而代之的是字段类型 
Lpackage/name/ObjectName;->FiedlName:Ljava/lang/String;

其中字段名与字段类型用冒号“:”分割

```
# static fields
.field private static instance:Lcn/woblog/markdowndiary/repository/LocalNoteRepository;


# instance fields
.field private final context:Landroid/content/Context;
```

其中： 
static fields：静态字段 
instance fields：实例字段

Dalvik指令集
他在调用格式上模仿了C语言的调用约定，官方地址,指令语法与助词有如下特点：

采用采用从目标(destination)到源(source)的方法
根据字节码的大小与类型不同，一些字节码添加了名称后缀已消除歧义 
2.1 32位常规类型的字节码未添加任何后缀 
2.2 64位常规类型的字节码添加 -wide后缀 
3.3 特殊类型的字节码根据具体类型添加后缀，-boolean,-byte,-char,-short,-int,-long,-float,-double,-object,-string,-class,-void之一
根据字节码的布局和选项不同，一些字节码添加了字节后缀消除歧义，后缀与字节码直接用/分割
在指令集的描述中，宽度值中每个字母表示宽度为4位
如： 
move-wide/from16 vAA, vBBBB 
move-wide/from16 v18, v0

move:基础字节码(base opcode)，标示是基本操作 
wide:标示指令操作的数据宽度为64位宽度 
from16:字节码后缀(opcode suffix),标示源(vBBBB)为一个16的寄存器引用变量 
vAA:目的寄存器，v0~v255 
vBBBB:源寄存器，v0~v65535

指令
nop
空操作，被用来做对齐代码

数据定义
用来定义程序中用到的常量，字符串，类等数据 
const/4 vA, #+B :将数组扩展为32位后赋给寄存器vA 
const/16 vAA, #+BBBB 
const vAA, #+BBBBBBBB：将数组赋值给寄存器vAA 
const-wide/16 vAA, #+BBBBB ：将数值扩展为64位后赋给寄存器vAA 
const-string vAA, string@BBBB：将字符串索引构造一个字符串并赋给vAA 
const-class vAA, type@BBBB:通过类型索引获取一个类的引用并赋给寄存器vAA

```java
private void testConst() {
    int a = 1;
    int b = 7;
    int c = 254;
    int d = 2345;
    int d1 = 65538;

    long e = 12435465657677L;
    float f = 123235409234.09097945F;
    double g = 111343333454999999999.912384375;
}
```

```
//-8到7用4，大于255小于等于65535用16
const/4 v0, 0x1

.line 25
.local v0, "a":I
const/4 v1, 0x7

.line 26
.local v1, "b":I
const/16 v2, 0xfe

.line 27
.local v2, "c":I
const/16 v3, 0x929

.line 28
.local v3, "d":I
const v4, 0x10002 //65538，大于65535用const v4

//long用const-wide
.line 30
.local v4, "d1":I
const-wide v6, 0xb4f5b835d4dL

.line 31
.local v6, "e":J
const v5, 0x51e58b39

.line 32
.local v5, "f":F
const-wide v8, 0x441824cbef6b9491L    # 1.11343333455E20
```

数据操作指令
move destination, source 
根据字节码大小和类型不同，后面回天津不同的后缀 
move vA, vB：vB寄存器值赋值给vA寄存器，都为4位 
move-object vA,vB 
move-result vAA：将上一个invoke类型的指令操作的单字非对象结果负责vAA寄存器 
move-result-object vAA：将上一个invoke类型指令操作的对象赋值给vAA 
move-exception vAA:保存一个运行时发生的异常vAA寄存器，必须是异常发生时的异常处理的第一条指令

```java
private void testMove() {
    int a = 100;
    long b = 100000000000000000L;

    int c = a;
    long d = b;

    Log.d(TAG,c+"");
    Log.d(TAG,d+"");


    int e = getIntResult();
    Log.d(TAG,e+"");

    try {
        int f = e/c;
    } catch (ArithmeticException e1) {
        e1.printStackTrace();
    }catch (Exception e1) {
        e1.printStackTrace();
    }finally {

    }
}
```

```
//move-result-object
invoke-direct {v7}, Ljava/lang/StringBuilder;-><init>()V

invoke-virtual {v7, v1}, Ljava/lang/StringBuilder;->append(I)Ljava/lang/StringBuilder;

move-result-object v7

const-string v8, ""

invoke-virtual {v7, v8}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

move-result-object v7

//move-result
invoke-direct {p0}, Lcom/woblog/testsmali/MainActivity;->getIntResult()I

move-result v6

//move exception
.line 35
:try_start_0
div-int v8, v6, v1
:try_end_0
.catch Ljava/lang/ArithmeticException; {:try_start_0 .. :try_end_0} :catch_0
.catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_1
.catchall {:try_start_0 .. :try_end_0} :catchall_0

.line 43
:goto_0
return-void

.line 36
:catch_0
move-exception v7

.line 37
.local v7, "e1":Ljava/lang/ArithmeticException;
:try_start_1
invoke-virtual {v7}, Ljava/lang/ArithmeticException;->printStackTrace()V
:try_end_1
.catchall {:try_start_1 .. :try_end_1} :catchall_0

goto :goto_0

.line 40
.end local v7    # "e1":Ljava/lang/ArithmeticException;
:catchall_0
move-exception v8

throw v8

.line 38
:catch_1
move-exception v7

.line 39
.local v7, "e1":Ljava/lang/Exception;
:try_start_2
invoke-virtual {v7}, Ljava/lang/Exception;->printStackTrace()V
:try_end_2
.catchall {:try_start_2 .. :try_end_2} :catchall_0

goto :goto_0
```

返回指令
return-void :返回一个void 
return vAA:返回一个32位非对象类型的值，返回寄存器为8位 
return-wide vAA：返回一个64位非对象类型的值，返回寄存器为8位 
return-object vAA:返回一个对象类型

```java
private String returnObject() {
    return new String("");
}

private float returnFloat() {
    return 12333334.00234345F;
}

private double returnDouble() {
    return 3425465767.9345865;
}

private long returnLong() {
    return 12445657999999L;
}

private int returnInt() {
    return 1024;
}

private void returnVoid() {
    int a = 3;
}
```


```
.method private returnDouble()D
    .locals 2

    .prologue
    .line 40
    const-wide v0, 0x41e9858eb4fde822L    # 3.4254657679345865E9

    return-wide v0
.end method

.method private returnFloat()F
    .locals 1

    .prologue
    .line 36
    const v0, 0x4b3c3116    # 1.2333334E7f

    return v0
.end method

.method private returnInt()I
    .locals 1

    .prologue
    .line 48
    const/16 v0, 0x400

    return v0
.end method

.method private returnLong()J
    .locals 2

    .prologue
    .line 44
    const-wide v0, 0xb51bb062a7fL

    return-wide v0
.end method

.method private returnObject()Ljava/lang/String;
    .locals 2

    .prologue
    .line 32
    new-instance v0, Ljava/lang/String;

    const-string v1, ""

    invoke-direct {v0, v1}, Ljava/lang/String;-><init>(Ljava/lang/String;)V

    return-object v0
.end method

.method private returnVoid()V
    .locals 1

    .prologue
    .line 52
    const/4 v0, 0x3

    .line 53
    .local v0, "a":I
    return-void
.end method
```

锁指令
锁指令多用在多线程程序中对同一对象的操作 
monitor-enter vAA 为指定的对象获取锁 
monitor-exit vAA 释放指定的对象的锁

```java
private void callSynchronizeClassMethod() {
    synchronized (MainActivity.class) {
        Log.d("TAG","synchronized class");
    }
}

private void callSynchronizeMethod() {
    synchronized (this) {
        Log.d("TAG","synchronized this");
    }
}

private synchronized void callLockMethod() {
    Log.d("TAG","synchronized method");
}
```

```
.method private declared-synchronized callLockMethod()V
    .locals 2

    .prologue
    .line 43
    monitor-enter p0

    :try_start_0
    const-string v0, "TAG"

    const-string v1, "synchronized method"

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I
    :try_end_0
    .catchall {:try_start_0 .. :try_end_0} :catchall_0

    .line 44
    monitor-exit p0

    return-void

    .line 43
    :catchall_0
    move-exception v0

    monitor-exit p0

    throw v0
.end method

.method private callSynchronizeClassMethod()V
    .locals 3

    .prologue
    .line 31
    const-class v1, Lcom/woblog/testsmali/MainActivity;

    monitor-enter v1

    .line 32
    :try_start_0
    const-string v0, "TAG"

    const-string v2, "synchronized class"

    invoke-static {v0, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 33
    monitor-exit v1

    .line 34
    return-void

    .line 33
    :catchall_0
    move-exception v0

    monitor-exit v1
    :try_end_0
    .catchall {:try_start_0 .. :try_end_0} :catchall_0

    throw v0
.end method

.method private callSynchronizeMethod()V
    .locals 2

    .prologue
    .line 37
    monitor-enter p0

    .line 38
    :try_start_0
    const-string v0, "TAG"

    const-string v1, "synchronized this"

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 39
    monitor-exit p0

    .line 40
    return-void

    .line 39
    :catchall_0
    move-exception v0

    monitor-exit p0
    :try_end_0
    .catchall {:try_start_0 .. :try_end_0} :catchall_0

    throw v0
.end method
```

实例操作
包括类型转换，检查和创建新实例 
check-cast vAA, type@BBBB：将vAA中的对象转为指定类型，如果失败会抛出ClassCastException异常，如果类型B是基本类型，对于分基本类型的A来说运行始终是失败的 
instance-of vA, vB, type@CCCC:判断vB寄存器的对象是否可以转为指定类型，如果可以vA为1，否则为0 
new-instance vAA, type@BBBB:构造一个指定类型的对象，并赋值给vAA寄存器，不能是数组类型

```java
CharSequence cs = new String();
Object o = cs;

String s = (String) cs;

//实例检测
if (s instanceof CharSequence) {
    Log.d("TAG", "ok");
} else {
    Log.d("TAG","no");
}


//创建实例
StringBuilder sb = new StringBuilder();
sb.append("Ok");

String s1 = new String("new string");
String s2 = "string";
```

```
new-instance v1, Ljava/lang/String;

invoke-direct {v1}, Ljava/lang/String;-><init>()V

.line 33
.local v1, "cs":Ljava/lang/CharSequence;
move-object v7, v1

.local v7, "o":Ljava/lang/CharSequence;
move-object v8, v1

.line 35
check-cast v8, Ljava/lang/String;

.line 38
.local v8, "s":Ljava/lang/String;
instance-of v12, v8, Ljava/lang/CharSequence;

if-eqz v12, :cond_0

.line 39
const-string v12, "TAG"

const-string v13, "ok"

invoke-static {v12, v13}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

.line 46
:goto_0
new-instance v11, Ljava/lang/StringBuilder;

invoke-direct {v11}, Ljava/lang/StringBuilder;-><init>()V

.line 47
.local v11, "sb":Ljava/lang/StringBuilder;
const-string v12, "Ok"

invoke-virtual {v11, v12}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

.line 49
new-instance v9, Ljava/lang/String;

const-string v12, "new string"

invoke-direct {v9, v12}, Ljava/lang/String;-><init>(Ljava/lang/String;)V

.line 50
.local v9, "s1":Ljava/lang/String;
const-string v10, "string"

.line 51
.local v10, "s2":Ljava/lang/String;
return-void

.line 41
.end local v9    # "s1":Ljava/lang/String;
.end local v10    # "s2":Ljava/lang/String;
.end local v11    # "sb":Ljava/lang/StringBuilder;
:cond_0
const-string v12, "TAG"

const-string v13, "no"

invoke-static {v12, v13}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

goto :goto_0
```

数组操作
包括获取数组长度，新建数组，数组赋值，数组元素取值与赋值等 
array-length vA, vB:获取vB寄存器中数组的长度并赋值给vA寄存器 
new-array vA, vB, type@CCCC：构造指定类型(type@CCCC)与大小(vB)的数组，并赋值给vA寄存器 
filled-new-array {vC,vD,vE,vF,vG}, type@BBBB:构造指定类型(type@BBBB)与大小vA的数组并填充数组内容，除了指定数组的大小还指定了参数个数 
filled-new-array/range {vCCCC .. vNNNN}, type@BBBB:与上一条类似，只是参数使用取值范围，vC是第一个参数寄存器，N=A+C-1 
fill-array-data vAA, +BBBBBBBB:vAA为寄存器数组引用，后面跟一个数据表 
arrayop vAA, vBB, vCC：对vBB寄存器指定的数组元素进入取值或赋值。vCC指定数组元素索引，vAA寄存器用来存放读取的或需要设置的值。读取元素使用age类指令，赋值使用aput类指令，根据数组中存储的类指令后面会跟不同的后缀： 
aget,aget-wide,aget-object,aget-boolean,aget-byte,aget-char,aget-short 
aput,aput-wide,aput-object,aput-boolean,aput-byte,aput-char,aput-short

```java
private void testArray() {
    int[] ints = new int[2];
    int[] ints1 = null;
    int[] ints2 = {1,2,3};

    Integer[] integers = new Integer[]{1,2,4};

    int[] strings = {1,2,3,4,5,6,5,6,6,6,6,6,6,7,7,8,8,8,8,8,1,1,1,3,3,5,6,54,5,6,56,567,67,6,34,45,45,6,56,57,45,45,5,56,56,7,34,543,543,6,56,56,45,4,54,5,45,56};

    //数组长度
    int length = ints.length;
    int length1 = ints2.length;
    int length2 = strings.length;

    //获取数组元素
    int string = strings[30];
    int string1 = ints2[1];

    //赋值
    strings[30] =  length;
    ints2[1] =  length2;
}
```

```
.method private testArray()V
    .locals 15

    .prologue
    const/16 v14, 0x1e

    const/4 v10, 0x3

    const/4 v13, 0x2

    const/4 v12, 0x1

    .line 27
    new-array v1, v13, [I

    .line 28
    .local v1, "ints":[I
    const/4 v2, 0x0

    .line 29
    .local v2, "ints1":[I
    new-array v3, v10, [I

    fill-array-data v3, :array_0

    .line 31
    .local v3, "ints2":[I
    new-array v0, v10, [Ljava/lang/Integer;

    const/4 v10, 0x0

    invoke-static {v12}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;

    move-result-object v11

    aput-object v11, v0, v10

    invoke-static {v13}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;

    move-result-object v10

    aput-object v10, v0, v12

    const/4 v10, 0x4

    invoke-static {v10}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;

    move-result-object v10

    aput-object v10, v0, v13

    .line 33
    .local v0, "integers":[Ljava/lang/Integer;
    const/16 v10, 0x3a

    new-array v9, v10, [I

    fill-array-data v9, :array_1

    .line 36
    .local v9, "strings":[I
    array-length v4, v1

    .line 37
    .local v4, "length":I
    array-length v5, v3

    .line 38
    .local v5, "length1":I
    array-length v6, v9

    .line 41
    .local v6, "length2":I
    aget v7, v9, v14

    .line 42
    .local v7, "string":I
    aget v8, v3, v12

    .line 45
    .local v8, "string1":I
    aput v4, v9, v14

    .line 46
    aput v6, v3, v12

    .line 47
    return-void

    .line 29
    :array_0
    .array-data 4
        0x1
        0x2
        0x3
    .end array-data

    .line 33
    :array_1
    .array-data 4
        0x1
        0x2
        0x3
        0x4
        0x5
        0x6
        0x5
        0x6
        0x6
        0x6
        0x6
        0x6
        0x6
        0x7
        0x7
        0x8
        0x8
        0x8
        0x8
        0x8
        0x1
        0x1
        0x1
        0x3
        0x3
        0x5
        0x6
        0x36
        0x5
        0x6
        0x38
        0x237
        0x43
        0x6
        0x22
        0x2d
        0x2d
        0x6
        0x38
        0x39
        0x2d
        0x2d
        0x5
        0x38
        0x38
        0x7
        0x22
        0x21f
        0x21f
        0x6
        0x38
        0x38
        0x2d
        0x4
        0x36
        0x5
        0x2d
        0x38
    .end array-data
.end method
```


异常指令
throw vAA:抛出vAA寄存器中指定类型的异常

```java
private void throw2() {
    try {
        throw new Exception("test throw runtime exception");
    } catch (Exception e) {
        e.printStackTrace();
    }
}

private void throw1() {
    throw new RuntimeException("test throw runtime exception");
}
```
```
.method private throw1()V
    .locals 2

    .prologue
    .line 38
    new-instance v0, Ljava/lang/RuntimeException;

    const-string v1, "test throw runtime exception"

    invoke-direct {v0, v1}, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V

    throw v0
.end method

.method private throw2()V
    .locals 3

    .prologue
    .line 31
    :try_start_0
    new-instance v1, Ljava/lang/Exception;

    const-string v2, "test throw runtime exception"

    invoke-direct {v1, v2}, Ljava/lang/Exception;-><init>(Ljava/lang/String;)V

    throw v1
    :try_end_0
    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0

    .line 32
    :catch_0
    move-exception v0

    .line 33
    .local v0, "e":Ljava/lang/Exception;
    invoke-virtual {v0}, Ljava/lang/Exception;->printStackTrace()V

    .line 35
    return-void
.end method
```

跳转指令
用于从当前地址跳转到指定的偏移处，提供了三种指令：无条件(goto),分支跳转(switch),条件跳转(if) 
goto +AA:无条件跳转到指定偏移处，AA不能为0 
goto/16 +AAAA 
goto/32 +AAAAAAAA

packed-switch vAA, +BBBBBBBB:分支跳转，vAA寄存器为switch分支需要判断的值

if-test vA, vB, +CCCC 条件跳转指令，比较vA寄存器与vB寄存器的值，如果比较结果满足就跳转到CCCC指定的偏移处，不能为0，有以下几条：

if-eq:if(vA==vB) 
if-ne:vA!=vB 
if-lt:vA

```java
private void testIfz() {
    int a = 3;
    if (a == 0) {

    } else {

    }
    if (a != 0) {

    } else {

    }
    if (a < 0) {

    } else {

    }
    if (a > 0) {

    } else {

    }
    if (a <= 0) {

    } else {

    }
    if (a >= 0) {

    } else {

    }

    if (a < 5) {
        Log.d("TAG", "<5");
    } else if (a > 5) {
        Log.d("TAG", ">5");
    } else {
        Log.d("TAG", "=5");
    }
}

private void testIf() {
    int a = 2;
    int b = 3;
    if (a == b) {

    } else {

    }
    if (a != b) {

    } else {

    }
    if (a < b) {

    } else {

    }
    if (a > b) {

    } else {

    }
    if (a <= b) {

    } else {

    }
    if (a >= b) {

    } else {

    }

}
```

```
.method private testIf()V
    .locals 2

    .prologue
    .line 69
    const/4 v0, 0x2

    .line 70
    .local v0, "a":I
    const/4 v1, 0x3

    .line 71
    .local v1, "b":I
    if-ne v0, v1, :cond_0

    .line 76
    :cond_0
    if-eq v0, v1, :cond_1

    .line 81
    :cond_1
    if-ge v0, v1, :cond_2

    .line 86
    :cond_2
    if-le v0, v1, :cond_3

    .line 91
    :cond_3
    if-gt v0, v1, :cond_4

    .line 96
    :cond_4
    if-lt v0, v1, :cond_5

    .line 102
    :cond_5
    return-void
.end method

.method private testIfz()V
    .locals 3

    .prologue
    const/4 v1, 0x5

    .line 27
    const/4 v0, 0x3

    .line 28
    .local v0, "a":I
    if-nez v0, :cond_0

    .line 33
    :cond_0
    if-eqz v0, :cond_1

    .line 38
    :cond_1
    if-gez v0, :cond_2

    .line 43
    :cond_2
    if-lez v0, :cond_3

    .line 48
    :cond_3
    if-gtz v0, :cond_4

    .line 53
    :cond_4
    if-ltz v0, :cond_5

    .line 59
    :cond_5
    if-ge v0, v1, :cond_6

    .line 60
    const-string v1, "TAG"

    const-string v2, "<5"

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 66
    :goto_0
    return-void

    .line 61
    :cond_6
    if-le v0, v1, :cond_7

    .line 62
    const-string v1, "TAG"

    const-string v2, ">5"

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    goto :goto_0

    .line 64
    :cond_7
    const-string v1, "TAG"

    const-string v2, "=5"

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    goto :goto_0
.end method
```

比较指令
用于对两个寄存器的值比较 
cmpkind vAA, vBB, vCC：vBB和vCC为要比较的值，结果放到vAA中 
cmpl-float:单精度，vBB大于vCC，vAA=-1,等于vAA=0,小于vAA=1 
cmpg-float：单精度，vBB大于vCC，vAA=1,等于vAA=0,小于vAA=-1 
cmpl-double:双精度 
cmpg-double:双精度 
cmp-long:长整形

```java
private void testCmpLong() {
    long a = 13;
    long b = 12;
    if (a < b) {
        Log.d("TAG", "<");
    } else if (a > b) {
        Log.d("TAG", ">");
    } else {
        Log.d("TAG", "=");
    }
}

private void testCmpDouble() {
    double a = 13.4;
    double b = 11.4;
    if (a < b) {
        Log.d("TAG", "<");
    } else if (a > b) {
        Log.d("TAG", ">");
    } else {
        Log.d("TAG", "=");
    }
}

private void testCmpFloat() {
    float a = 13.4F;
    float b = 10.4F;
    if (a < b) {
        Log.d("TAG", "<");
    } else if (a > b) {
        Log.d("TAG", ">");
    } else {
        Log.d("TAG", "=");
    }
}
```

```
.method private testCmpDouble()V
    .locals 6

    .prologue
    .line 46
    const-wide v0, 0x402acccccccccccdL    # 13.4

    .line 47
    .local v0, "a":D
    const-wide v2, 0x4026cccccccccccdL    # 11.4

    .line 48
    .local v2, "b":D
    cmpg-double v4, v0, v2

    if-gez v4, :cond_0

    .line 49
    const-string v4, "TAG"

    const-string v5, "<"

    invoke-static {v4, v5}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 55
    :goto_0
    return-void

    .line 50
    :cond_0
    cmpl-double v4, v0, v2

    if-lez v4, :cond_1

    .line 51
    const-string v4, "TAG"

    const-string v5, ">"

    invoke-static {v4, v5}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    goto :goto_0

    .line 53
    :cond_1
    const-string v4, "TAG"

    const-string v5, "="

    invoke-static {v4, v5}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    goto :goto_0
.end method

.method private testCmpFloat()V
    .locals 4

    .prologue
    .line 58
    const v0, 0x41566666    # 13.4f

    .line 59
    .local v0, "a":F
    const v1, 0x41266666    # 10.4f

    .line 60
    .local v1, "b":F
    cmpg-float v2, v0, v1

    if-gez v2, :cond_0 #>=

    .line 61
    const-string v2, "TAG"

    const-string v3, "<"

    invoke-static {v2, v3}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 67
    :goto_0
    return-void

    .line 62
    :cond_0
    cmpl-float v2, v0, v1

    if-lez v2, :cond_1 #<=

    .line 63
    const-string v2, "TAG"

    const-string v3, ">"

    invoke-static {v2, v3}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    goto :goto_0

    .line 65
    :cond_1
    const-string v2, "TAG"

    const-string v3, "="

    invoke-static {v2, v3}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    goto :goto_0
.end method

.method private testCmpLong()V
    .locals 6

    .prologue
    .line 34
    const-wide/16 v0, 0xd

    .line 35
    .local v0, "a":J
    const-wide/16 v2, 0xc

    .line 36
    .local v2, "b":J
    cmp-long v4, v0, v2

    if-gez v4, :cond_0

    .line 37
    const-string v4, "TAG"

    const-string v5, "<"

    invoke-static {v4, v5}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 43
    :goto_0
    return-void

    .line 38
    :cond_0
    cmp-long v4, v0, v2

    if-lez v4, :cond_1

    .line 39
    const-string v4, "TAG"

    const-string v5, ">"

    invoke-static {v4, v5}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    goto :goto_0

    .line 41
    :cond_1
    const-string v4, "TAG"

    const-string v5, "="

    invoke-static {v4, v5}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    goto :goto_0
.end method
```

字段操作指令
用来对 对象实例的字段进行读写操作。字段类型可以是Java中有效的类型，对于实例字段和静态字段有两类指令： 
iget,iput对实例字段进行读，写 
sget,sput对静态字段

会根据类型不同添加不同的后缀 
iget，iget-wide,iget-object,iget-boolean,iget-byte,iget-char,iget-short 
iput,iput-wide,iput-object,iput-boolean,iput-byte,iput-char,iput-short

sget,sget-wide,sget-object,sget-boolean,sget-byte,sget-char,sget-short 

```java
private void testInstanceFieldOperator() {
    //write
    InstanceObject instanceObject = new InstanceObject();
    instanceObject.aInt=1;
    instanceObject.aLong=12454L;
    instanceObject.aFloat=12344.45F;
    instanceObject.aDouble=123546.2;
    instanceObject.object=new Object();
    instanceObject.aBoolean=true;
    instanceObject.aByte=3;
    instanceObject.aChar='c';
    instanceObject.aShort=1;

    Log.d("TAG",String.valueOf(instanceObject.aInt));
    Log.d("TAG",String.valueOf(instanceObject.aLong));
    Log.d("TAG",String.valueOf(instanceObject.aFloat));
    Log.d("TAG",String.valueOf(instanceObject.aDouble));
    Log.d("TAG",String.valueOf(instanceObject.object));
    Log.d("TAG",String.valueOf(instanceObject.aBoolean));
    Log.d("TAG",String.valueOf(instanceObject.aByte));
    Log.d("TAG",String.valueOf(instanceObject.aChar));
    Log.d("TAG",String.valueOf(instanceObject.aShort));
}

private void testStatusFieldOperator() {
    //write
    StatusObject.aInt=1;
    StatusObject.aLong=12454L;
    StatusObject.aFloat=12344.45F;
    StatusObject.aDouble=123546.2;
    StatusObject.object=new Object();
    StatusObject.aBoolean=true;
    StatusObject.aByte=3;
    StatusObject.aChar='c';
    StatusObject.aShort=1;

    Log.d("TAG",String.valueOf(StatusObject.aInt));
    Log.d("TAG",String.valueOf(StatusObject.aLong));
    Log.d("TAG",String.valueOf(StatusObject.aFloat));
    Log.d("TAG",String.valueOf(StatusObject.aDouble));
    Log.d("TAG",String.valueOf(StatusObject.object));
    Log.d("TAG",String.valueOf(StatusObject.aBoolean));
    Log.d("TAG",String.valueOf(StatusObject.aByte));
    Log.d("TAG",String.valueOf(StatusObject.aChar));
    Log.d("TAG",String.valueOf(StatusObject.aShort));
}
```

```
.method private testInstanceFieldOperator()V
    .locals 5

    .prologue
    const/4 v4, 0x1

    .line 30
    new-instance v0, Lcom/woblog/testsmali/InstanceObject;

    invoke-direct {v0}, Lcom/woblog/testsmali/InstanceObject;-><init>()V

    .line 31
    .local v0, "instanceObject":Lcom/woblog/testsmali/InstanceObject;
    iput v4, v0, Lcom/woblog/testsmali/InstanceObject;->aInt:I

    .line 32
    const-wide/16 v2, 0x30a6

    iput-wide v2, v0, Lcom/woblog/testsmali/InstanceObject;->aLong:J

    .line 33
    const v1, 0x4640e1cd

    iput v1, v0, Lcom/woblog/testsmali/InstanceObject;->aFloat:F

    .line 34
    const-wide v2, 0x40fe29a333333333L    # 123546.2

    iput-wide v2, v0, Lcom/woblog/testsmali/InstanceObject;->aDouble:D

    .line 35
    new-instance v1, Ljava/lang/Object;

    invoke-direct {v1}, Ljava/lang/Object;-><init>()V

    iput-object v1, v0, Lcom/woblog/testsmali/InstanceObject;->object:Ljava/lang/Object;

    .line 36
    iput-boolean v4, v0, Lcom/woblog/testsmali/InstanceObject;->aBoolean:Z

    .line 37
    const/4 v1, 0x3

    iput-byte v1, v0, Lcom/woblog/testsmali/InstanceObject;->aByte:B

    .line 38
    const/16 v1, 0x63

    iput-char v1, v0, Lcom/woblog/testsmali/InstanceObject;->aChar:C

    .line 39
    iput-short v4, v0, Lcom/woblog/testsmali/InstanceObject;->aShort:S

    .line 41
    const-string v1, "TAG"

    iget v2, v0, Lcom/woblog/testsmali/InstanceObject;->aInt:I

    invoke-static {v2}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;

    move-result-object v2

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 42
    const-string v1, "TAG"

    iget-wide v2, v0, Lcom/woblog/testsmali/InstanceObject;->aLong:J

    invoke-static {v2, v3}, Ljava/lang/String;->valueOf(J)Ljava/lang/String;

    move-result-object v2

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 43
    const-string v1, "TAG"

    iget v2, v0, Lcom/woblog/testsmali/InstanceObject;->aFloat:F

    invoke-static {v2}, Ljava/lang/String;->valueOf(F)Ljava/lang/String;

    move-result-object v2

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 44
    const-string v1, "TAG"

    iget-wide v2, v0, Lcom/woblog/testsmali/InstanceObject;->aDouble:D

    invoke-static {v2, v3}, Ljava/lang/String;->valueOf(D)Ljava/lang/String;

    move-result-object v2

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 45
    const-string v1, "TAG"

    iget-object v2, v0, Lcom/woblog/testsmali/InstanceObject;->object:Ljava/lang/Object;

    invoke-static {v2}, Ljava/lang/String;->valueOf(Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v2

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 46
    const-string v1, "TAG"

    iget-boolean v2, v0, Lcom/woblog/testsmali/InstanceObject;->aBoolean:Z

    invoke-static {v2}, Ljava/lang/String;->valueOf(Z)Ljava/lang/String;

    move-result-object v2

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 47
    const-string v1, "TAG"

    iget-byte v2, v0, Lcom/woblog/testsmali/InstanceObject;->aByte:B

    invoke-static {v2}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;

    move-result-object v2

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 48
    const-string v1, "TAG"

    iget-char v2, v0, Lcom/woblog/testsmali/InstanceObject;->aChar:C

    invoke-static {v2}, Ljava/lang/String;->valueOf(C)Ljava/lang/String;

    move-result-object v2

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 49
    const-string v1, "TAG"

    iget-short v2, v0, Lcom/woblog/testsmali/InstanceObject;->aShort:S

    invoke-static {v2}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;

    move-result-object v2

    invoke-static {v1, v2}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 50
    return-void
.end method

.method private testStatusFieldOperator()V
    .locals 4

    .prologue
    const/4 v2, 0x1

    .line 54
    sput v2, Lcom/woblog/testsmali/StatusObject;->aInt:I

    .line 55
    const-wide/16 v0, 0x30a6

    sput-wide v0, Lcom/woblog/testsmali/StatusObject;->aLong:J

    .line 56
    const v0, 0x4640e1cd

    sput v0, Lcom/woblog/testsmali/StatusObject;->aFloat:F

    .line 57
    const-wide v0, 0x40fe29a333333333L    # 123546.2

    sput-wide v0, Lcom/woblog/testsmali/StatusObject;->aDouble:D

    .line 58
    new-instance v0, Ljava/lang/Object;

    invoke-direct {v0}, Ljava/lang/Object;-><init>()V

    sput-object v0, Lcom/woblog/testsmali/StatusObject;->object:Ljava/lang/Object;

    .line 59
    sput-boolean v2, Lcom/woblog/testsmali/StatusObject;->aBoolean:Z

    .line 60
    const/4 v0, 0x3

    sput-byte v0, Lcom/woblog/testsmali/StatusObject;->aByte:B

    .line 61
    const/16 v0, 0x63

    sput-char v0, Lcom/woblog/testsmali/StatusObject;->aChar:C

    .line 62
    sput-short v2, Lcom/woblog/testsmali/StatusObject;->aShort:S

    .line 64
    const-string v0, "TAG"

    sget v1, Lcom/woblog/testsmali/StatusObject;->aInt:I

    invoke-static {v1}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;

    move-result-object v1

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 65
    const-string v0, "TAG"

    sget-wide v2, Lcom/woblog/testsmali/StatusObject;->aLong:J

    invoke-static {v2, v3}, Ljava/lang/String;->valueOf(J)Ljava/lang/String;

    move-result-object v1

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 66
    const-string v0, "TAG"

    sget v1, Lcom/woblog/testsmali/StatusObject;->aFloat:F

    invoke-static {v1}, Ljava/lang/String;->valueOf(F)Ljava/lang/String;

    move-result-object v1

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 67
    const-string v0, "TAG"

    sget-wide v2, Lcom/woblog/testsmali/StatusObject;->aDouble:D

    invoke-static {v2, v3}, Ljava/lang/String;->valueOf(D)Ljava/lang/String;

    move-result-object v1

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 68
    const-string v0, "TAG"

    sget-object v1, Lcom/woblog/testsmali/StatusObject;->object:Ljava/lang/Object;

    invoke-static {v1}, Ljava/lang/String;->valueOf(Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v1

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 69
    const-string v0, "TAG"

    sget-boolean v1, Lcom/woblog/testsmali/StatusObject;->aBoolean:Z

    invoke-static {v1}, Ljava/lang/String;->valueOf(Z)Ljava/lang/String;

    move-result-object v1

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 70
    const-string v0, "TAG"

    sget-byte v1, Lcom/woblog/testsmali/StatusObject;->aByte:B

    invoke-static {v1}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;

    move-result-object v1

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 71
    const-string v0, "TAG"

    sget-char v1, Lcom/woblog/testsmali/StatusObject;->aChar:C

    invoke-static {v1}, Ljava/lang/String;->valueOf(C)Ljava/lang/String;

    move-result-object v1

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 72
    const-string v0, "TAG"

    sget-short v1, Lcom/woblog/testsmali/StatusObject;->aShort:S

    invoke-static {v1}, Ljava/lang/String;->valueOf(I)Ljava/lang/String;

    move-result-object v1

    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    .line 73
    return-void
.end method
```

方法调用
在方法调用者我们可以看到有：

```
invoke-super {p0, p1}, Lcom/woblog/testsmali/BaseActivity;->onCreate(Landroid/os/Bundle;)V

invoke-virtual {p0, v0}, Lcom/woblog/testsmali/MainActivity;->setContentView(I)V

invoke-direct {p0}, Lcom/woblog/testsmali/MainActivity;->initMove()V

invoke-static {}, Lcom/woblog/testsmali/TimeUtil;->getCurrentTime()J

invoke-interface {v0}, Lcom/woblog/testsmali/ICallback;->onSuccess()V
```


数据转换
数据转换指令用于将一种数据类型转换为另一个类型，unop vA, vB:寄存器存储要转换的数据，vA存储转换后的数据 
neg-int:整形求补 
not-int:整形求反 
neg-long:长整型求补 
not-long:长整型求反 
neg-float:单精度求补 
not-float: 
neg-double: 
not-double:

int-to-long:整型转为长整型 
int-to-float:整型转单精度浮点型 
int-to-double:整型转双精度浮点型

int-to-byte:整型转字节型 
int-to-char:整型转字符串 
int-to-short:整型转短整型

long-to-int 
long-to-float 
long-to-double

float-to-int 
float-to-long 
float-to-double

double-to-int 
double-to-long 
double-to-float

```java
private void testConvert() {
    int i1=13;

    //int 转其他类型
    long l1 = i1;
    float f1 = i1;
    double d1 = i1;

    byte b1 = (byte) i1;
    char c1 = (char) i1;
    short s1 = (short) i1;

    //long 转其他类型
    long l2 = 234444556576L;
    int i2 = (int) l2;
    float f2 = l2;
    double d2 = l2;

    //float 转其他类型
    float f10 =234399.9F;
    int i10 = (int) f10;
    long l10 = (long) f10;
    double d10 = f10;

    //double 转其他类型
    double d20 = 123344445.324;
    int i20 = (int) d20;
    long l20 = (long) d20;
    float f20 = (float) d20;
}
```

```
.method private testConvert()V
    .locals 29

    .prologue
    .line 30
    const/16 v16, 0xd

    .line 33
    .local v16, "i1":I
    move/from16 v0, v16

    int-to-long v0, v0

    move-wide/from16 v20, v0

    .line 34
    .local v20, "l1":J
    move/from16 v0, v16

    int-to-float v12, v0

    .line 35
    .local v12, "f1":F
    move/from16 v0, v16

    int-to-double v4, v0

    .line 37
    .local v4, "d1":D
    move/from16 v0, v16

    int-to-byte v2, v0

    .line 38
    .local v2, "b1":B
    move/from16 v0, v16

    int-to-char v3, v0

    .line 39
    .local v3, "c1":C
    move/from16 v0, v16

    int-to-short v0, v0

    move/from16 v28, v0

    .line 42
    .local v28, "s1":S
    const-wide v24, 0x3695fc0920L

    .line 43
    .local v24, "l2":J
    move-wide/from16 v0, v24

    long-to-int v0, v0

    move/from16 v18, v0

    .line 44
    .local v18, "i2":I
    move-wide/from16 v0, v24

    long-to-float v14, v0

    .line 45
    .local v14, "f2":F
    move-wide/from16 v0, v24

    long-to-double v8, v0

    .line 48
    .local v8, "d2":D
    const v13, 0x4864e7fa    # 234399.9f

    .line 49
    .local v13, "f10":F
    float-to-int v0, v13

    move/from16 v17, v0

    .line 50
    .local v17, "i10":I
    float-to-long v0, v13

    move-wide/from16 v22, v0

    .line 51
    .local v22, "l10":J
    float-to-double v6, v13

    .line 54
    .local v6, "d10":D
    const-wide v10, 0x419d6858f54bc6a8L    # 1.23344445324E8

    .line 55
    .local v10, "d20":D
    double-to-int v0, v10

    move/from16 v19, v0

    .line 56
    .local v19, "i20":I
    double-to-long v0, v10

    move-wide/from16 v26, v0

    .line 57
    .local v26, "l20":J
    double-to-float v15, v10

    .line 58
    .local v15, "f20":F
    return-void
.end method
```
数据运行指令
算术运算：加，减，乘，除，模，移位等 
逻辑运算：与，或，非，异或等

binop vAA, vBB, vCC：将vBB寄存器与vCC寄存器进行运算，结果保存到vAA

上面的指令会根据数据类型的不同在基础后面添加数据类型后缀，如：-int或-long 
add-type vBB：vBB寄存器与vCC寄存器值进行加法运算,+ 
sub-type vBB:- 
mul-type vBB:* 
div-type vBB:/ 
rem-type vBB:% 
and-type vBB:and 
or-type vBB:or 
xor-type vBB:xor 
shl-type vBB:左移vCC位，<< 
shr-type vBB:右移vCC位，>> 
ushr-type vBB:无符号>>

其中type可以为int,long,float,double

binop/2addr vA, vB:将vA寄存器与vB寄存器进行运算，结果保存到vA 
binop/lit16 vA, vB, #+CCCC:将vB寄存器与常量CCCC进行运算，结果保存到vA 
binop/lit8 vAA, vBB, #+CC:将vBB寄存器与常量CC进行运行，结果保存到vAA

Dalvik hello world
首先写一个基本框架

```
.class public LHelloWorld; #定义类名
.super Ljava/lang/Object; #定义父类
.method public static main([Ljava/lang/String;)V #声明静态的main函数
    .locals 4 #使用的寄存器个数，包括一个参数寄存器
    .param p0, "args" #一个参数

    .prologue #代码起始指令


    # 这里是代码主体


    return-void
.end method
```

完整版如下：

```
.class public LHelloWorld; #定义类名
.super Ljava/lang/Object; #定义父类
.method public static main([Ljava/lang/String;)V #声明静态的main函数
    .locals 4 #使用的寄存器个数，包括一个参数寄存器
    .param p0, "args" #一个参数

    .prologue #代码起始指令


    const-string v1, "Hello World"

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    invoke-virtual {v0,v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V


    return-void
.end method
```
编译smali
我们去官网下载smali.jar，然后运行
``` java -jar smali.jar -o classes.dex HelloWorld.smali ```
编译完后我们把classes.dex push到手机里面
``` adb push classes.dex /data/local/  ```

运行

``` dalvikvm -cp /data/local/classes.dex HelloWorld ```

加强版本
```
.class public LHelloWorld; #定义类名
.super Ljava/lang/Object; #定义父类
.method public static main([Ljava/lang/String;)V #声明静态的main函数
    .locals 10 #使用的寄存器个数，包括一个参数寄存器
    .param p0, "args" #一个参数

    .prologue #代码起始指令

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    # 空指令

    nop

    nop

    nop


    # 数据定义指令

    const/4 v2, 0x3

    const/16 v3, 0xffff ##不能大于65535

    #大于65535用-wide

    const-wide v4, 0x10000


    # 定义一个类 类型

    const-class v5, Ljava/lang/String;


    # 数据操作指令

    move v6, v2

    new-instance v7, Ljava/lang/StringBuilder;

    invoke-direct {v7}, Ljava/lang/StringBuilder;-><init>()V

    const-string v8, "\u8fd9\u662f\u4e00\u4e2a\u624b\u5199\u7684\u0073\u006d\u0061\u006c\u0069\u5b9e\u4f8b"

    invoke-virtual {v7, v8}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    move-result-object v7

    invoke-virtual {v7}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;

    move-result-object v9

    invoke-virtual {v0, v9}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V


    # 打印字符串

    const-string v1, "Hello World"


    invoke-virtual {v0,v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V


    return-void
.end method
```


# android逆向分析之smali语法

一 、smali数据类型

1．Dalvik字节码

Davlik字节码中，寄存器都是32位的，能够支持任何类型，64位类型（Long/Double）用2个连续的寄存器表示；

Dalvik字节码有两种类型：原始类型；引用类型（包括对象和数组）

 原始类型：

         v   void  只能用于返回值类型
          Z   boolean
          B   byte
          S   short
          C   char
          I    int
          J    long（64位）
          F   float
          D   double（64位）
对象类型：
Lpackage/name/ObjectName;       相当于java中的package.name.ObjectName;
     L：表示这是一个对象类型
     package/name:该对象所在的包
    ；：表示对象名称的结束
 
2．数组的表示形式：
[I  :表示一个整形的一维数组，相当于java的int[]；对于多维数组，只要增加[ 就行了，[[I = int[][];注：每一维最多255个；
对象数组的表示形式：[Ljava/lang/String表示一个String的对象数组；
 
3．方法的表示形式：
  Lpackage/name/ObjectName;->methodName(III)Z
          Lpackage/name/ObjectName  表示类型
          methodName   表示方法名
          III   表示参数（这里表示为3个整型参数）说明：方法的参数是一个接一个的，中间没有隔开
 
4．字段的表示形式：
Lpackage/name/ObjectName;->FieldName:Ljava/lang/String；即表示：包名，字段名和字段类型
 
5．寄存器指定
有两种方式指定一个方法中有多少寄存器是可用的：
.registers  指令指定了方法中寄存器的总数
.locals    指令表明了方法中非参寄存器的总数，出现在方法中的第一行
 
6．方法的表示
方法有直接方法和虚方法两种，直接方法的声明格式如下：
.method<访问权限>[修饰关键字]<方法原型>
<.locals>
[.parameter]
[.prologue]
[.line]
<代码体>
.end method
 
访问权限有public、private等，修饰关键字有static、constructor等。方法原型描述了方法的名称、参数与返回值。
.registers指定了方法中寄存器的总数
.locals指定了方法中非参寄存器的总数（局部变量的个数）；
.parameter指定了方法的参数；
.prologue指定了代码的开始处；
.line指定了该处指令在源代码中的位置。
 
注意：构造函数的返回类型为V，名字为<init>。
 
7．方法的传参：
当一个方法被调用的时候，方法的参数被置于最后N个寄存器中；
例如：一个方法有2个参数，5个寄存器（v0~v4），那么，参数将置于最后2个寄存器（v3和v4）。非静态方法中的第一个参数总是调用该方法的对象。
说明：对于静态方法除了没有隐含的this参数外，其他都一样
 
8．寄存器的命名方式：V命名、P命名
第一个寄存器就是方法中的第一个参数寄存器。比较：使用P命名是为了防止以后如果在方法中增加寄存器，需要对参数寄存器重新进行编号的缺点。特别说明一下：Long和Double类型是64位的，需要2个连续的寄存器
例如：对于非静态方法LMyObject->myMethod(IJZ)V，有4个参数：  LMyObject(隐含的),int,long,boolean
需要5个寄存器（因为long占有2个连续的寄存器）来存储参数：
     P0    this（非静态方法中这个参数是隐含的）
     P1    I (int)
     P2，P3  J (long)
     P4    Z(bool)
 
如果是静态的就是三个参数
     P0   I (int)
     P1，P2 J (long)
     P3    Z(bool)
 
二、成员变量
static fields             定义静态变量的标记
instance fields        定义实例变量的标记
direct methods       定义静态方法的标记
virtual methods      定义非静态方法的标记
  
三、控制条件
"if-eq vA, vB, :cond_**"   如果vA等于vB则跳转到:cond_**
"if-ne vA, vB, :cond_**"   如果vA不等于vB则跳转到:cond_**
"if-lt vA, vB, :cond_**"    如果vA小于vB则跳转到:cond_**
"if-ge vA, vB, :cond_**"   如果vA大于等于vB则跳转到:cond_**
"if-gt vA, vB, :cond_**"   如果vA大于vB则跳转到:cond_**
"if-le vA, vB, :cond_**"    如果vA小于等于vB则跳转到:cond_**
"if-eqz vA, :cond_**"   如果vA等于0则跳转到:cond_**
"if-nez vA, :cond_**"   如果vA不等于0则跳转到:cond_**
"if-ltz vA, :cond_**"    如果vA小于0则跳转到:cond_**
"if-gez vA, :cond_**"   如果vA大于等于0则跳转到:cond_**
"if-gtz vA, :cond_**"   如果vA大于0则跳转到:cond_**
"if-lez vA, :cond_**"    如果vA小于等于0则跳转到:cond_**

 z 既可以表示zero（0） 也可以是null、或者false;具体看逻辑。

 四、switch分支语句
```
.method private packedSwitch(I)Ljava/lang/String;
    .locals 1
    .parameter "i"
    .prologue
    .line 21
    const/4 v0, 0x0
    .line 22
    .local v0, str:Ljava/lang/String;  #v0为字符串，0表示null
    packed-switch p1, :pswitch_data_0  #packed-switch分支，pswitch_data_0指定case区域
    .line 36
    const-string v0, "she is a person"  #default分支
    .line 39
    :goto_0      #所有case的出口
    return-object v0 #返回字符串v0
    .line 24
    :pswitch_0    #case 0
    const-string v0, "she is a baby"
    .line 25
    goto :goto_0  #跳转到goto_0标号处
    .line 27
    :pswitch_1    #case 1
    const-string v0, "she is a girl"
    .line 28
    goto :goto_0  #跳转到goto_0标号处
    .line 30
    :pswitch_2    #case 2
    const-string v0, "she is a woman"
    .line 31
    goto :goto_0  #跳转到goto_0标号处
    .line 33
    :pswitch_3    #case 3
    const-string v0, "she is an obasan"
    .line 34
    goto :goto_0  #跳转到goto_0标号处
    .line 22
    nop
    :pswitch_data_0
    .packed-switch 0x0    #case  区域，从0开始，依次递增
        :pswitch_0  #case 0
        :pswitch_1  #case 1
        :pswitch_2  #case 2
        :pswitch_3  #case 3
    .end packed-switch
.end method
```
packed-switch 指令。p1为传递进来的 int 类型的数值，pswitch_data_0 为case 区域，在 case 区域中，第一条指令“.packed-switch”指定了比较的初始值为0 ，pswitch_0~ pswitch_3分别是比较结果为“case 0 ”到“case 3 ”时要跳转到的地址。可以发现，标号的命名采用 pswitch_ 开关，后面的数值为 case 分支需要判断的值，并且它的值依次递增。再来看看这些标号处的代码，每个标号处都使用v0 寄存器初始化一个字符串，然后跳转到了goto_0 标号处，可见goto_0 是所有的 case 分支的出口。另外，“.packed-switch”区域指定的case 分支共有4 条，对于没有被判断的 default 分支，会在代码的 packed-switch指令下面给出。

 至此，有规律递增的 switch 分支就算是搞明白了。最后，将这段 smali 代码整理为Java代码如下。

```java
private String packedSwitch(int i) {
    String str = null;
    switch (i) {
        case 0:
            str = "she is a baby";
            break;
        case 1:
            str = "she is a girl";
            break;
        case 2:
            str = "she is a woman";
            break;
        case 3:
            str = "she is an obasan";
            break;
        default:
            str = "she is a person";
            break;
    }
    return str;
}
``` 

现在我们来看看无规律的case 分支语句代码会有什么不同

```
.method private sparseSwitch(I)Ljava/lang/String;
    .locals 1
    .parameter "age"
    .prologue
    .line 43
    const/4 v0, 0x0
    .line 44
    .local v0, str:Ljava/lang/String;
    sparse-switch p1, :sswitch_data_0  # sparse-switch分支，sswitch_data_0指定case区域
    .line 58
    const-string v0, "he is a person"  #case default
    .line 61
    :goto_0    #case 出口
    return-object v0  #返回字符串
    .line 46
    :sswitch_0    #case 5
    const-string v0, "he is a baby"
    .line 47
    goto :goto_0 #跳转到goto_0标号处
    .line 49
    :sswitch_1    #case 15
    const-string v0, "he is a student"
    .line 50
    goto :goto_0 #跳转到goto_0标号处
    .line 52
    :sswitch_2    #case 35
    const-string v0, "he is a father"
    .line 53
    goto :goto_0 #跳转到goto_0标号处
    .line 55
    :sswitch_3    #case 65
    const-string v0, "he is a grandpa"
    .line 56
    goto :goto_0 #跳转到goto_0标号处
    .line 44
    nop
    :sswitch_data_0
    .sparse-switch            #case 区域
        0x5 -> :sswitch_0     #case 5(0x5)
        0xf -> :sswitch_1     #case 15(0xf)
        0x23 -> :sswitch_2    #case 35(0x23)
        0x41 -> :sswitch_3    #case 65(0x41)
    .end sparse-switch
.end method
```

按照分析packed-switch 的方法，我们直接查看 sswitch_data_0 标号处的内容。可以看到“.sparse-switch ”指令没有给出初始case 的值，所有的case 值都使用“case 值 -> case 标号”的形式给出。此处共有4 个case ，它们的内容都是构造一个字符串，然后跳转到goto_0 标号处，代码架构上与packed-switch 方式的 switch 分支一样。

最后，将这段smali 代码整理为Java 代码如下。
```java
private String sparseSwitch(int age) {
    String str = null;
    switch (age) {
        case 5:
            str = "he is a baby";
            break;
        case 15:
            str = "he is a student";
            break;
        case 35:
            str = "he is a father";
            break;
        case 65:
            str = "he is a grandpa";
            break;
        default:
            str = "he is a person";
            break;
    }
    return str;
}
```

五、try/catch 语句

```
.method private tryCatch(ILjava/lang/String;)V
    .locals 10
    .parameter "drumsticks"
    .parameter "peple"
    .prologue
    const/4 v9, 0x0
                                                                                                                                                              .line 19
    try_start_0                                                              # 第1个try开始
    invoke-static {p2}, Ljava/lang/Integer;->parseInt(Ljava/lang/String;)I   #将第2个参数转换为int 型
    :try_end_0                                                               # 第1个try结束
    .catch Ljava/lang/NumberFormatException; {:try_start_0 .. :try_end_0} : catch_1  # catch_1
     move-result v1          #如果出现异常这里不会执行，会跳转到catch_1标号处
                                                                                                                                                               .line 21
    .local v1, i:I            #.local声明的变量作用域在.local声明与.end local 之间
   :try_start_1               #第2个try 开始
    div-int v2, p1, v1        # 第1个参数除以第2个参数
    .line 22
    .local v2, m:I
    mul-int v5, v2, v1        #m * i
    sub-int v3, p1, v5        #v3  = p1 - v5
    .line 23
    .local v3, n:I
    const-string v5, "\u5171\u6709%d\u53ea\u9e21\u817f\uff0c%d
        \u4e2a\u4eba\u5e73\u5206\uff0c\u6bcf\u4eba\u53ef\u5206\u5f97%d
        \u53ea\uff0c\u8fd8\u5269\u4e0b%d\u53ea"   # 格式化字符串
    const/4 v6, 0x4
    new-array v6, v6, [Ljava/lang/Object;
    const/4 v7, 0x0
    .line 24
    invoke-static {p1}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v8
    aput-object v8, v6, v7
    const/4 v7, 0x1
    invoke-static {v1}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v8
    aput-object v8, v6, v7
    const/4 v7, 0x2
    invoke-static {v2}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v8
    aput-object v8, v6, v7
    const/4 v7, 0x3
    invoke-static {v3}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v8

    aput-object v8, v6, v7
    .line 23
    invoke-static {v5, v6}, Ljava/lang/String;
        ->format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
    move-result-object v4
    .line 25
    .local v4, str:Ljava/lang/String;
    const/4 v5, 0x0
    invoke-static {p0, v4, v5}, Landroid/widget/Toast;
        ->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)
        Landroid/widget/Toast;
    move-result-object v5
    invoke-virtual {v5}, Landroid/widget/Toast;->show()V # 使用Toast 显示格式化后的结果
   :try_end_1                                            #第2个try 结束
    .catch Ljava/lang/ArithmeticException; {:try_start_1 .. :try_end_1} : catch_0    # catch_0
    .catch Ljava/lang/NumberFormatException; {:try_start_1 .. :try_end_1} : catch_1  # catch_1
    .line 33
    .end local v1           #i:I
    .end local v2           #m:I
    .end local v3           #n:I
    .end local v4           #str:Ljava/lang/String;
    :goto_0
    return-void             # 方法返回
    .line 26
    .restart local v1       #i:I
    :catch_0
    move-exception v0
    .line 27
    .local v0, e:Ljava/lang/ArithmeticException;
                                                                                                                                                              :try_start_2                                       #第3个try 开始
    const-string v5, "\u4eba\u6570\u4e0d\u80fd\u4e3a0"           #“人数不能为0”
    const/4 v6, 0x0
    invoke-static {p0, v5, v6}, Landroid/widget/Toast;
        ->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)
        Landroid/widget/Toast;
    move-result-object v5
    invoke-virtual {v5}, Landroid/widget/Toast;->show()V         #使用Toast 显示异常原因
    :try_end_2                                                   #第3个try 结束
    .catch Ljava/lang/NumberFormatException; {:try_start_2 .. :try_end_2} :catch_1
     goto :goto_0 #返回
    .line 29
    .end local v0           #e:Ljava/lang/ArithmeticException;
    .end local v1           #i:I
    :catch_1
    move-exception v0
    .line 30
    .local v0, e:Ljava/lang/NumberFormatException;
    const-string v5, "\u65e0\u6548\u7684\u6570\u503c\u5b57\u7b26\u4e32"
    #“无效的数值字符串”
    invoke-static {p0, v5, v9}, Landroid/widget/Toast;
        ->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)
        Landroid/widget/Toast;
    move-result-object v5
    invoke-virtual {v5}, Landroid/widget/Toast;->show()V # 使用Toast 显示异 常原因
    goto :goto_0                                         #返回
.end method
```

代码中的try语句块使用try_start_开头的标号注明，以try_end_开头的标号结束。第一个try语句的开头标号为try_start_0，结束标号为 try_end_0。使用多个try语句块时标号名称后面的数值依次递增，本实例代码中最多使用到了try_end_2。
在try_end_0 标号下面使用“.catch”指令指定处理到的异常类型与catch的标号，格式如下。

.catch < 异常类型> {<try起始标号> .. <try 结束标号>} <catch标号>

查看catch_1标号处的代码发现，当转换 String 到int 时发生异常会弹出“无效的数值字符串”的提示。对于代码中的汉字，baksmali 在反编译时将其使用Unicode进行编码，因此，在阅读前需要使用相关的编码转换工具进行转换。

仔细阅读代码会发现在try_end_1标号下面使用“.catch”指令定义了 catch_0与catch_1两个catch。catch_0标号的代码开头又有一个标号为try_start_2的try 语句块，其实这个try语句块是虚构的，假如下面的代码。

```java
private void a() {
    try {
        ……
        try {
            ……
        } catch (XXX) {
            ……
        }
    } catch (YYY) {
        ……
    }
}
```

当执行内部的try语句时发生了异常，如果异常类型为XXX，则内部catch就会捕捉到并执行相应的处理代码，如果异常类型不是 XXX，那么就会到外层的 catch中去查找异常处理代码，这也就是为什么实例的try_end_1标号下面会有两个catch的原因，另外，如果在执行XXX异常的处理代码时又发生了异常，这个时候该怎么办？此时这个异常就会扩散到外层的catch中去，由于XXX异常的外层只有一个YYY的异常处理，这时会判断发生的异常是否为YYY类型，如果是就会进行处理，不是则抛给应用程序。回到本实例中来，如果在执行内部的ArithmeticException异常处理时再次发生别的异常，就会调用外层的 catch进行异常捕捉，因此在try_end_2标号下面有一个 catch_1就很好理解了。
最后，将这段 smali 代码整理为Java 代码如下。

```java
private void tryCatch(int drumsticks, String peple) {
        try {
            int i = Integer.parseInt(peple);
            try {
                int m = drumsticks / i;
                int n = drumsticks - m * i;
                String str = String.format("共有%d只鸡腿，%d个人平分，每人可分得%d只，还剩下%d只",drumsticks, i, m, n);
                Toast.makeText(MainActivity.this, str,Toast.LENGTH_SHORT).show();
            } catch (ArithmeticException e) {
                Toast.makeText(MainActivity.this, " 人数不能为0",Toast.LENGTH_SHORT).show();
            }
        } catch (NumberFormatException e) {
            Toast.makeText(MainActivity.this, " 无效的数值字符串",Toast.LENGTH_SHORT).show();
        }
}
```
finally语句块
源码：

```java
try {
            ServerSocket serverSocket= new ServerSocket(10000);
            Socket socket=serverSocket.accept();
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
           int abc=5;
           Toast.makeText(this, "sssss ", Toast.LENGTH_SHORT).show();
    }
```

finally 语句块作用：执行一些必要代码。即不管出现异常与否，在finally中的代码都会被执行
执行时机：针对所有catch语句之后，退出方法之前将被执行（即先执行catch里面的代码，但在throw之前将转向finally）。finally中返回的结果将可以覆盖catch中返回的结果
对应的smail代码如下： 

```
:try_start_0
    new-instance v2, Ljava/net/ServerSocket;        #ServerSocket v2 = null;
    const/16 v3, 0x2710                             # v3 = 10000;
    invoke-direct {v2, v3}, Ljava/net/ServerSocket;-><init>(I)V  # v2 = new ServerSocket(v3);
    .line 21
    .local v2, serverSocket:Ljava/net/ServerSocket;
    invoke-virtual {v2}, Ljava/net/ServerSocket;->accept()Ljava/net/Socket; # v2.accept( );
    :try_end_0
    .catchall {:try_start_0 .. :try_end_0} :catchall_0
//上一句处理start_0对应的异常块是catchall_0   也就是finally
    .catch Ljava/io/IOException; {:try_start_0 .. :try_end_0} :catch_0
//上一句处理start_0对应的异常块是catch_0，catch_0异常块先执行，之后再执行catchall_0
```

相对应的smali代码为： 
```
:try_start_0
    new-instance v2, Ljava/net/ServerSocket;
    const/16 v3, 0x2710
    invoke-direct {v2, v3}, Ljava/net/ServerSocket;-><init>(I)V
    .line 21
    .local v2, serverSocket:Ljava/net/ServerSocket;
    invoke-virtual {v2}, Ljava/net/ServerSocket;->accept()Ljava/net/Socket;
    :try_end_0

    .catchall {:try_start_0 .. :try_end_0} :catchall_0
    .catch Ljava/io/IOException; {:try_start_0 .. :try_end_0} :catch_0
    .line 27
    const/4 v0, 0x5      #正常流程 即未发生异常
    .line 28
    .local v0, abc:I
    const-string v3, "sssss "
    invoke-static {p0, v3, v5}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;
    move-result-object v3
    invoke-virtual {v3}, Landroid/widget/Toast;->show()V
    .line 32
    .end local v2        #serverSocket:Ljava/net/ServerSocket;
    :goto_0
    return-void
    .line 22
    .end local v0        #abc:I

   :catch_0              #当发生异常时执行
    move-exception v1
    .line 24
    .local v1, e:Ljava/io/IOException;

    :try_start_1
      invoke-virtual {v1}, Ljava/io/IOException;->printStackTrace()V
    :try_end_1
    .catchall {:try_start_1 .. :try_end_1} :catchall_0    #异常部分执行完毕，转而执行finally

    .line 27
    const/4 v0, 0x5
    .line 28
    .restart local v0       #abc:I
    const-string v3, "sssss "
    invoke-static {p0, v3, v5}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;
    move-result-object v3
    invoke-virtual {v3}, Landroid/widget/Toast;->show()V
    goto :goto_0
    .line 25
    .end local v0           #abc:I
    .end local v1           #e:Ljava/io/IOException;

  #finally代码定义部分
    :catchall_0
    move-exception v3
    .line 27
    const/4 v0, 0x5
    .line 28
    .restart local v0       #abc:I
    const-string v4, "sssss "
    invoke-static {p0, v4, v5}, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;
    move-result-object v4
    invoke-virtual {v4}, Landroid/widget/Toast;->show()V
    .line 30
    throw v3
```
六、for循环
```
# virtual methods
.method public onClick(Landroid/view/View;)V
.locals 9
.parameter “v”

.prologue
.line 36
invoke-virtual {p1}, Landroid/view/View;->getId()I  # 非静态方法参数中隐含的第一个参数p0为this指针, p1为第一个参数, 即View对象

move-result v6     # 把上次的计算结果给第七个寄存器,v6=p1.getId(), v6中为View对象的id

packed-switch v6, :pswitch_data_0    # switch(v6)

# —————– 程序出口开始 ——————
.line 58
:goto_0         # for循环出口
return-void     # return;
# —————– 程序出口结束 ——————

# —————– 获取控件内容开始 ——————
.line 39
:pswitch_0
iget-object v6, p0, Lcom/sanwho/crackdemo/ForActivity$1;->this$0:Lcom/sanwho/crackdemo/ForActivity;  # v6保存this指针

const v7, 0x7f080001   # v7 = txtValue1, 该id保存在public.xml中

invoke-virtual {v6, v7}, Lcom/sanwho/crackdemo/ForActivity;->findViewById(I)Landroid/view/View; # findViewById(txtValue1)

move-result-object v4  # v4为txtValue1对应的View对象

check-cast v4, Landroid/widget/EditText;  # 将View对象转换成EditText, 完成后v4中是txtValue1对象, 失败会抛出ClassCastException异常

.line 40
.local v4, txtValue1:Landroid/widget/EditText;
iget-object v6, p0, Lcom/sanwho/crackdemo/ForActivity$1;->this$0:Lcom/sanwho/crackdemo/ForActivity;

const v7, 0x7f080003  # v7 = txtValue2

invoke-virtual {v6, v7}, Lcom/sanwho/crackdemo/ForActivity;->findViewById(I)Landroid/view/View;

move-result-object v5  # v5为txtValue2对应的View对象

check-cast v5, Landroid/widget/EditText;  # 将View对象转换成EditText, 完成后v5中是txtValue2对象

.line 41
.local v5, txtValue2:Landroid/widget/EditText;
invoke-virtual {v4}, Landroid/widget/EditText;->getText()Landroid/text/Editable;    # 根据.line 39处可知，v4中为txtValue1对象

move-result-object v6   # v6 = txtValue1.getText();

invoke-interface {v6}, Landroid/text/Editable;->toString()Ljava/lang/String;

move-result-object v6   # v6 = txtValue1.getText().toString();

invoke-static {v6}, Ljava/lang/Integer;->parseInt(Ljava/lang/String;)I

move-result v1    # v1 = Integer.parseInt(v6); 也就是起始数值

.line 42
.local v1, from:I
invoke-virtual {v5}, Landroid/widget/EditText;->getText()Landroid/text/Editable;    # 根据.line 40处可知，v5中为txtValue2对象

move-result-object v6  # v6 = txtValue2.getText();

invoke-interface {v6}, Landroid/text/Editable;->toString()Ljava/lang/String;

move-result-object v6  # v6 = txtValue2.getText().toString();

invoke-static {v6}, Ljava/lang/Integer;->parseInt(Ljava/lang/String;)I

move-result v0    # v0 = Integer.parseInt(v6); 也就是结束数值

# —————– 获取控件内容结束 ——————

.line 43
.local v0, end:I
if-le v1, v0, :cond_0   # if v1 <= v0, 即起始数值 <= 结束数值, 则跳到cond_0

# —————– 起始数值 > 结束数值时开始 ——————
.line 45
iget-object v6, p0, Lcom/sanwho/crackdemo/ForActivity$1;->this$0:Lcom/sanwho/crackdemo/ForActivity;

const-string v7, “\u8d77\u59cb\u6570\u503c\u4e0d\u80fd\u5927\u4e8e\u7ed3\u675f\u6570\u503c!”  # 起始数值不能大于结束数值

#calls: Lcom/sanwho/crackdemo/ForActivity;->MessageBox(Ljava/lang/String;)V
invoke-static {v6, v7}, Lcom/sanwho/crackdemo/ForActivity;->access$0(Lcom/sanwho/crackdemo/ForActivity;Ljava/lang/String;)V

goto :goto_0

# —————– 起始数值 > 结束数值时结束 ——————

# —————– 起始数值 <= 结束数值时开始 —————–
.line 49
:cond_0
const/4 v3, 0x0   # v3 = 0, 即int sum = 0;

.line 50
.local v3, sum:I
move v2, v1       # v2 = v1, v2即源码中的i变量

.local v2, i:I
:goto_1           # for循环主要入口
if-le v2, v0, :cond_1   # if 当前数值 <= 结束数值, 跳到cond_1;  否则循环结束, 显示累加结果

.line 54
iget-object v6, p0, Lcom/sanwho/crackdemo/ForActivity$1;->this$0:Lcom/sanwho/crackdemo/ForActivity;  # v6指向MessageBox方法

new-instance v7, Ljava/lang/StringBuilder;    # v7为StringBuilder对象

const-string v8, “\u7d2f\u52a0\u7ed3\u679c\uff1a”  # v8 = “累加结果：”

invoke-direct {v7, v8}, Ljava/lang/StringBuilder;-><init>(Ljava/lang/String;)V  # 以v8为参数调用StringBuilder构造函数

invoke-static {v3}, Ljava/lang/Integer;->toString(I)Ljava/lang/String; # 把int型的sum值转成字符串

move-result-object v8   # v8 = Integer.toString(v3); 此时v8中为sum的值

invoke-virtual {v7, v8}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;   # 把累加结果和sum的值进行追加

move-result-object v7  # v7 为 “累加结果：” + Integer.toString(sum)的StringBuilder对象;

invoke-virtual {v7}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;  # 将v7转为字符串对象

move-result-object v7   # v7 = “累加结果：” + Integer.toString(sum);

#calls: Lcom/sanwho/crackdemo/ForActivity;->MessageBox(Ljava/lang/String;)V
invoke-static {v6, v7}, Lcom/sanwho/crackdemo/ForActivity;->access$0(Lcom/sanwho/crackdemo/ForActivity;Ljava/lang/String;)V  # 调用MessageBox显示字符串

goto :goto_0  # 跳到goto_0
# —————– 起始数值 <= 结束数值时结束 —————–

.line 52
:cond_1           # 加1操作入口
add-int/2addr v3, v2   # v3 = v3 + v2, 即sum += i

.line 50
add-int/lit8 v2, v2, 0x1  # v2 = v2 + 1, , 即i = i + 1

goto :goto_1   # 跳到for循环入口继续比对

.line 36
nop

:pswitch_data_0
.packed-switch 0x7f080004
:pswitch_0
.end packed-switch
.end method
```

源码解释

```java
Button.OnClickListener onClickListener = new Button.OnClickListener()
{
    @Override
    public void onClick(View v)
    {
        switch (v.getId())
        {
        case R.id.btnSubmit:
            EditText txtValue1 = (EditText) findViewById(R.id.txtValue1);
            EditText txtValue2 = (EditText) findViewById(R.id.txtValue2);
            int from = Integer.parseInt(txtValue1.getText().toString());
            int end = Integer.parseInt(txtValue2.getText().toString());
            if (from > end){
                MessageBox("起始数值不能大于结束数值!");
            }
            else
            {
                 int sum = 0;
                 for (int i = from; i <= end; i++){

                     sum += i;
                 }
                 MessageBox("累加结果：" + Integer.toString(sum));
            }
            break;
        }
    }
};

private void MessageBox(String str)
{
    Toast.makeText(this, str, Toast.LENGTH_LONG).show();
}
```
如果看不懂access$0或者this$0等请看下一章节

八、内部类

Java 语言允许在一个类的内部定义另一个类，这种在类中定义的类被称为内部类（Inner Class）。内部类可分为成员内部类、静态嵌套类、方法内部类、匿名内部类。前面我们曾经说过，baksmali 在反编译dex 文件的时候，会为每个类单独生成了一个 smali 文件，内部类作为一个独立的类，它也拥有自己独立的smali 文件，只是内部类的文件名形式为“[外部类]$[内部类].smali ”，例如下面的类。
```java
class OUter{
        class Inner{}
}
```

baksmali 反编译上述代码后会在同一目录生成两个文件：Outer.smali 与Outer$Inner.smali。

```java
public class MainActivity extends Activity {
    private Button btnAnno;
    private Button btnCheckSN;
    private EditText edtSN;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        btnAnno = (Button) findViewById(R.id.btn_annotation);
        btnCheckSN = (Button) findViewById(R.id.btn_checksn);
        edtSN = (EditText) findViewById(R.id.edt_sn);
        btnAnno.setOnClickListener(new OnClickListener() {
           @Override
            public void onClick(View v) {
                getAnnotations();
            }
        });

        btnCheckSN.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                SNChecker checker = new SNChecker(edtSN.getText().toString());
                String str = checker.isRegistered() ? "注册码正确" : "注册码错误";
                Toast.makeText(MainActivity.this, str, Toast.LENGTH_SHORT).show();
            }
        });
    }

    private void getAnnotations() {
        try {
            Class<?> anno = Class.forName("com.droider.anno.MyAnno");
            if (anno.isAnnotationPresent(MyAnnoClass.class)) {
                MyAnnoClass myAnno = anno.getAnnotation(MyAnnoClass.class);
                Toast.makeText(this, myAnno.value(), Toast.LENGTH_SHORT).show();
            }
            Method method = anno.getMethod("outputInfo", (Class[])null);
            if (method.isAnnotationPresent(MyAnnoMethod.class)) {
                MyAnnoMethod myMethod = method.getAnnotation(MyAnnoMethod.class);
                String str = myMethod.name() + " is " + myMethod.age() + " years old.";
                Toast.makeText(this, str, Toast.LENGTH_SHORT).show();
            }
            Field field = anno.getField("sayWhat");
            if (field.isAnnotationPresent(MyAnnoField.class)) {
                MyAnnoField myField = field.getAnnotation(MyAnnoField.class);
                Toast.makeText(this, myField.info(), Toast.LENGTH_SHORT).show();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.activity_main, menu);
        return true;
    }

    public class SNChecker {
        private String sn;
        public SNChecker(String sn) {
            this.sn = sn;
        }

        public boolean isRegistered() {
            boolean result = false;
            char ch = '\0';
            int sum = 0;
            if (sn == null || (sn.length() < 8)) return result;
            int len = sn.length();
            if (len == 8) {
                ch = sn.charAt(0);
                switch (ch) {
                    case 'a':
                    case 'f':
                        result = true;
                        break;
                    default:
                        result = false;
                        break;
                }
                if (result) {
                    ch = sn.charAt(3);
                    switch (ch) {
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                            result = true;
                            break;
                        default:
                            result = false;
                            break;
                    }
                }
            } else if (len == 16) {
                for (int i = 0; i < len; i++) {
                    char chPlus = sn.charAt(i);
                    sum += (int) chPlus;
                }
                result = ((sum % 6) == 0) ? true : false;
            }
            return result;
        }
    }
}
```

MainActivity$ SNChecker.smali 文件，这个SNChecker 就是MainActivity的一个内部类。打开这个文件，代码结构如下。

```
.class public Lcom/droider/crackme0502/MainActivity$SNChecker;
.super Ljava/lang/Object;
.source "MainActivity.java"


# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = Lcom/droider/crackme0502/MainActivity;
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x1
    name = "SNChecker"
.end annotation


# instance fields
.field private sn:Ljava/lang/String;

.field final synthetic this$0:Lcom/droider/crackme0502/MainActivity;


# direct methods
.method public constructor <init>(Lcom/droider/crackme0502/MainActivity;Ljava/lang/String;)V
    .locals 0
    .parameter
    .parameter "sn"

    .prologue
    .line 83
    iput-object p1, p0, Lcom/droider/crackme0502/MainActivity$SNChecker;->this$0:Lcom/droider/crackme0502/MainActivity;

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    .line 84
    iput-object p2, p0, Lcom/droider/crackme0502/MainActivity$SNChecker;->sn:Ljava/lang/String;

    .line 85
    return-void
.end method


# virtual methods
.method public isRegistered()Z
    .locals 10

    .prologue
    const/16 v9, 0x8

    const/4 v7, 0x0

    .line 88
    const/4 v4, 0x0

    .line 89
    .local v4, result:Z
    const/4 v0, 0x0

    .line 90
    .local v0, ch:C
    const/4 v6, 0x0

    .line 91
    .local v6, sum:I
    iget-object v8, p0, Lcom/droider/crackme0502/MainActivity$SNChecker;->sn:Ljava/lang/String;

    if-eqz v8, :cond_0

    iget-object v8, p0, Lcom/droider/crackme0502/MainActivity$SNChecker;->sn:Ljava/lang/String;

    invoke-virtual {v8}, Ljava/lang/String;->length()I

    move-result v8

    if-ge v8, v9, :cond_1

    :cond_0
    move v5, v4

    .line 126
    .end local v4           #result:Z
    .local v5, result:I
    :goto_0
    return v5

    .line 92
    .end local v5           #result:I
    .restart local v4       #result:Z
    :cond_1
    iget-object v8, p0, Lcom/droider/crackme0502/MainActivity$SNChecker;->sn:Ljava/lang/String;

    invoke-virtual {v8}, Ljava/lang/String;->length()I

    move-result v3

    .line 93
    .local v3, len:I
    if-ne v3, v9, :cond_3

    .line 94
    iget-object v8, p0, Lcom/droider/crackme0502/MainActivity$SNChecker;->sn:Ljava/lang/String;

    invoke-virtual {v8, v7}, Ljava/lang/String;->charAt(I)C

    move-result v0

    .line 95
    sparse-switch v0, :sswitch_data_0

    .line 101
    const/4 v4, 0x0

    .line 104
    :goto_1
    if-eqz v4, :cond_2

    .line 105
    iget-object v7, p0, Lcom/droider/crackme0502/MainActivity$SNChecker;->sn:Ljava/lang/String;

    const/4 v8, 0x3

    invoke-virtual {v7, v8}, Ljava/lang/String;->charAt(I)C

    move-result v0

    .line 106
    packed-switch v0, :pswitch_data_0

    .line 115
    const/4 v4, 0x0

    :cond_2
    :goto_2
    move v5, v4

    .line 126
    .restart local v5       #result:I
    goto :goto_0

    .line 98
    .end local v5           #result:I
    :sswitch_0
    const/4 v4, 0x1

    .line 99
    goto :goto_1

    .line 112
    :pswitch_0
    const/4 v4, 0x1

    .line 113
    goto :goto_2

    .line 119
    :cond_3
    const/16 v8, 0x10

    if-ne v3, v8, :cond_2

    .line 120
    const/4 v2, 0x0

    .local v2, i:I
    :goto_3
    if-lt v2, v3, :cond_4

    .line 124
    rem-int/lit8 v8, v6, 0x6

    if-nez v8, :cond_5

    const/4 v4, 0x1

    :goto_4
    goto :goto_2

    .line 121
    :cond_4
    iget-object v8, p0, Lcom/droider/crackme0502/MainActivity$SNChecker;->sn:Ljava/lang/String;

    invoke-virtual {v8, v2}, Ljava/lang/String;->charAt(I)C

    move-result v1

    .line 122
    .local v1, chPlus:C
    add-int/2addr v6, v1

    .line 120
    add-int/lit8 v2, v2, 0x1

    goto :goto_3

    .end local v1           #chPlus:C
    :cond_5
    move v4, v7

    .line 124
    goto :goto_4

    .line 95
    :sswitch_data_0
    .sparse-switch
        0x61 -> :sswitch_0
        0x66 -> :sswitch_0
    .end sparse-switch

    .line 106
    :pswitch_data_0
    .packed-switch 0x31
        :pswitch_0
        :pswitch_0
        :pswitch_0
        :pswitch_0
        :pswitch_0
    .end packed-switch
.end method
```

发现它有两个注解定义块“Ldalvik/annotation/EnclosingClass;”与“Ldalvik/annotation/ InnerClass; ”、两个实例字段sn 与this$0 、一个直接方法 init()、一个虚方法isRegistered() 。注解定义块我们稍后进行讲解。先看它的实例字段，sn 是字符串类型，this$0 是MainActivity类型，synthetic 关键字表明它是“合成”的，那 this$0 到底是个什么东西呢？

其实this$0 是内部类自动保留的一个指向所在外部类的引用。左边的 this 表示为父类的引用，右边的数值0 表示引用的层数。我们看下面的类。

```java
public class Outer {    //this$0
     public class FirstInner {        //this$1
            public class SecondInner {      //this$2
                public class ThirdInner {
                }
        }
    }
}
```

每往里一层右边的数值就加一，如 ThirdInner类访问 FirstInner 类的引用为this$1 。在生成的反汇编代码中，this$X 型字段都被指定了synthetic 属性，表明它们是被编译器合成的、虚构的，代码的作者并没有声明该字段。

我们再看看MainActivity$SNChecker的构造函数，看它是如何初始化的。代码如下。

```
# direct methods
.method public constructor <init>(Lcom/droider/crackme0502/MainActivity;Ljava/lang/String;)V
    .locals 0
    .parameter       #第一个参数MainActivity引用
    .parameter "sn"  #第二个参数字符串sn

    .prologue
    .line 83
    #将MainActivity引用赋值给this$0
    iput-object p1, p0, Lcom/droider/crackme0502/MainActivity$SNChecker;->this$0:Lcom/droider/crackme0502/MainActivity;

    #调用默认的构造函数
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    .line 84
    #将sn字符串的值赋给sn字段
    iput-object p2, p0, Lcom/droider/crackme0502/MainActivity$SNChecker;->sn:Ljava/lang/String;

    .line 85
    return-void
.end method
```

对于一个非静态的方法而言，会隐含的使用p0寄存器当作类的this 引用。因此，这里的确是使用了3 个寄存器：p0表示MainActivity$SNChecker自身的引用，p1表示MainActivity的引用，p2表示sn 字符串。另外，从 MainActivity$SNChecker的构造函数可以看出，内部类的初始化共有以下 3 个步骤：首先是保存外部类的引用到本类的一个 synthetic字段中，以便内部类的其它方法使用，然后是调用内部类的父类的构造函数来初始化父类，最后是对内部类自身进行初始化。


一个方法中指定的寄存器个
在一个方法（method）中有两中方式指定有多少个可用的寄存器。指令.registers指令指定了在这个方法中有多少个可用的寄存器，指令.locals指明了在这个方法中非参（non-parameter）寄存器的数量。然而寄存器的总数也包括保存方法参数的寄存器。

参数是如何传递的？
当一个方法被调用时，该方法的参数被保存在最后N个寄存器中。如果一个方法有2个参数和5个寄存器(V0-V4)，参数将被保存在最后的2个寄存器内V3和V4.

非静态方法的第一个参数，总是被方法调用的对象。
例如，你写了一个非静态方法LMyObject;->callMe(II)V。这个方法有2个int参数，但在这两个整型参数前面还有一个隐藏的参数LMyObject；所以这个方法总共有3个参数。

比如说，在方法中指定有5个寄存器(V0-V4)，只用.register指令指定5个，或者使用.locals指令指定2个（2个local寄存器+3个参数寄存器）。该方法被调用的时候，调用方法的对象（即this引用）会保存在V2中，第一个参数在V3中，第二个参数在v4中。

除了不包含this隐藏参数，对于静态方法都是相同的。

寄存器名称
有两种寄存器的命名方式，对于参数寄存器有普通的V命名方式和P命名方式。在方法（method）中第一个参数寄存器，是使用P方式命名的第一个寄存器，让我们回到前面的例子中，有三个参数和5个寄存器，下面的这个表显示了对每个寄存器的普通V命名方式，后面是P方式命名的参数寄存器。


v0	 	the first local register
v1	 	the second local register
v2	p0	the first parameter register
v3	p1	the second parameter register
v4	p2	the third parameter register


You can reference parameter registers by either name - it makes no difference.

你可以使用名称引用参数寄存器，他们没有区别。

引入参数寄存器的目的
P命名方式被引入去解决，在编辑smail代码时候共同的烦恼。

假设你有一个方法（mehtod），这个方法带有一些参数，并且你需要添加一些代码到这个方法中，这时发现需要一些额外的寄存器，你会想“没有什么大不了的。我只需要使用.registers指令添加寄存器数量就可以了。”
不幸的是没有想象的那么容易，请记住，方法中方法的参数被保存在最后的寄存器里。如果你增加了寄存器的数量，达到让寄存器中的参数被传入的目的。所以你不得不使用.registers指令重新分配参数寄存器的编号。
但如果在方法中P命名方式，被用来引用参数寄存器。你将很容易的在方法中去修改寄存器数量，而不用去担心现有寄存器的编号。

注意：在默认的baksmali中，参数寄存器将使用P命名方式，如果出于某种原因你要禁用P命名方式，而要强制使用V命名方式，应当使用-p/--no-parameter-registers选项。

Long/Double values
正如前面提到的，long和double类型都是64位，需要2个寄存器。当你引用参数的时候一定要记住，例如：你有一个非静态方法LMyObject;->MyMethod(IJZ)V,LMyObject方法的参数为int、long、bool。所以这个方法的所有参数需要5个寄存器。


p0	this
p1	I
p2, p3	J
p4	Z


另外当你调用方法后，你必须在寄存器列表，调用指令中指明，两个寄存器保存了double-wide宽度的参数。

  

关于几个调用方法指令： invoke-virtual、invoke-direct、invoke-super介绍。

涉及到Java强大的动态扩展能力，这一特性使得可以在类运行期间才能确定某些目标方法的实际引用，称为动态连接；也有一部分方法的符号引用在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。

在Java语言中，符合“编译器可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他的版本，因此它们都适合在类加载阶段进行解析。 

invoke-static 是类静态方法的调用，编译时，静态确定的；
invoke-virtual 虚方法调用，调用的方法运行时确认实际调用，和实例引用的实际对象有关，动态确认的，一般是带有修饰符protected或public的方法；
invoke-direct 没有被覆盖方法的调用，即不用动态根据实例所引用的调用，编译时，静态确认的，一般是private或<init>方法；
invoke-super 直接调用父类的虚方法，编译时，静态确认的。
invokeinterface 调用接口方法，调用的方法运行时确认实际调用，即会在运行时才确定一个实现此接口的对象。




